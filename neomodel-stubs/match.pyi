# Stubs for neomodel.match (Python 3)

from typing import (Any, Dict, Generic, Iterator, List, Optional, Type,
                    TypeVar, Union)

from .core import NodeBase, StructuredNode
from .match_q import Q

OUTGOING: Any
INCOMING: Any
EITHER: Any
basestring = str
OPERATOR_TABLE: Any

def _rel_helper(
    lhs: str,
    hrs: str,
    ident: str,
    relation_type: Optional[str],
    direction: Optional[str],
    relation_properties: Dict,
    **kwargs: Any
) -> str: ...
def install_traversals(cls: StructuredNode, node_set: NodeSet) -> None: ...
def process_filter_args(cls: StructuredNode, kwargs: Any) -> None: ...
def process_has_args(cls: StructuredNode, kwargs: Any) -> None: ...

class QueryBuilder:
    node_set: Any = ...
    _ast: Dict[str, Any] = ...
    _query_params: Dict = ...
    _place_holder_registry: Dict = ...
    _ident_count: int = ...
    def __init__(self, node_set: Any) -> None: ...
    def build_ast(self) -> "QueryBuilder": ...
    def build_source(
        self, source: Union[NodeSet, StructuredNode, Traversal]
    ) -> str: ...
    def create_ident(self) -> str: ...
    def build_order_by(self, ident: str, source: Any) -> None: ...
    def build_traversal(self, traversal: Any) -> str: ...
    def build_node(self, node: Any) -> str: ...
    def build_label(self, ident: str, cls: Any) -> str: ...
    def build_additional_match(self, ident: Any, node_set: Any) -> None: ...
    def _register_place_holder(self, key: str) -> str: ...
    def _parse_q_filters(self, ident: str, q: Any, source_class: Any) -> str: ...
    def build_where_stmt(
        self,
        ident: Any,
        filters: Any,
        q_filters: Optional[Any] = ...,
        source_class: Optional[Any] = ...,
    ) -> str: ...
    def build_query(self) -> str: ...

T = TypeVar("T")

class BaseSet(Generic[T]):
    query_cls: QueryBuilder = ...
    def all(self, lazy: bool = ...) -> List[T]: ...
    def __iter__(self) -> Iterator: ...
    def __len__(self) -> int: ...
    def __bool__(self) -> bool: ...
    def __nonzero__(self) -> bool: ...
    def __contains__(self, obj: StructuredNode) -> bool: ...
    limit: int = ...
    skip: int = ...
    def __getitem__(self, key: Union[int, slice]) -> T: ...

class NodeSet(BaseSet[T]):
    source: Union[StructuredNode, Type[StructuredNode], Traversal] = ...
    source_class: Type[T] = ...
    filters: List = ...
    q_filters: Q = ...
    must_match: Dict = ...
    dont_match: Dict = ...
    def __init__(
        self, source: Union[StructuredNode, Type[StructuredNode], Traversal]
    ) -> None: ...
    def get(self: "NodeSet[Type[T]]", lazy: bool = ..., **kwargs: Any) -> T: ...
    def get_or_none(self, **kwargs: Any) -> Optional[T]: ...
    def first(self, **kwargs: Any) -> T: ...
    def first_or_none(self, **kwargs: Any) -> Optional[T]: ...
    def filter(self, *args: Any, **kwargs: Any) -> "NodeSet": ...
    def exclude(self, *args: Any, **kwargs: Any) -> "NodeSet": ...
    def has(self, **kwargs: Any) -> "NodeSet": ...
    def order_by(self, *props: Any) -> "NodeSet": ...

class Traversal(BaseSet):
    source: Union[NodeSet, StructuredNode, Type[StructuredNode], "Traversal"] = ...
    source_class: Any = ...
    definition: Dict = ...
    target_class: Any = ...
    name: str = ...
    filters: Dict = ...
    def __init__(
        self,
        source: Union[NodeSet, StructuredNode, Type[StructuredNode], "Traversal"],
        name: str,
        definition: Dict,
    ) -> None: ...
    def match(self, **kwargs: Any) -> "Traversal": ...
